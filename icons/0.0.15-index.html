<!-- konetik index.html v0.0.15 -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>konetik</title>
    <meta name="description" content="A text-only Nostr client with Nostr-to-Hive bridging">
    <meta name="theme-color" content="#ffffff">
    <link rel="icon" href="data:image/x-icon;base64,AAABAAEAAQEAAAEAIAAwAAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <!-- <link rel="manifest" href="/manifest.json"> --> <!-- Paused -->
    <script id="dhive-script" src="https://cdn.jsdelivr.net/npm/@hiveio/dhive@1.3.0/dist/dhive.js"></script>
    <script id="dhive-fallback"></script>
    <script src="https://unpkg.com/nostr-tools@2.7.2/lib/nostr.bundle.js"></script>
    <style>
        body { font-family: monospace; max-width: 600px; margin: 0 auto; padding: 10px; }
        header { text-align: center; }
        section, div { margin: 10px 0; }
        input, textarea, select { width: 100%; padding: 5px; }
        button { padding: 5px 10px; margin: 5px 0; }
        h1 { font-family: 'Press Start 2P', monospace; color: cornflowerblue; font-size: 16px; }
        header p { font-family: 'Press Start 2P', monospace; color: #999; font-size: 12px; }
        #menu, #note-modal, #reply-modal, #about-modal, #security-modal, #sleep-overlay, #post-info-modal { display: none; }
        #sleep-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); color: white; text-align: center; padding-top: 50%; }
        #post-info-modal { position: fixed; top: 20%; left: 10%; right: 10%; background: #fff; border: 1px solid #000; padding: 20px; text-align: center; }
        #security-modal { position: fixed; top: 20%; left: 10%; right: 10%; background: #fff; border: 1px solid #000; padding: 20px; text-align: left; }
        .error { color: red; }
        .status { font-size: 0.9em; }
        .info { font-size: 0.8em; color: #555; }
        input[type="password"] { -webkit-text-security: disc; text-security: disc; }
    </style>
</head>
<body>
    <header>
        <h1>konetik</h1>
        <p>nostr-hive kinetic connect</p>
    </header>

    <!-- Login Section -->
    <section id="login-section">
        <h2>login</h2>
        <nav>
            <a href="https://nstart.me" target="_blank" rel="noopener noreferrer">join nostr</a> | <a href="#about" id="about-link">about konetik</a>
        </nav>
        <p>Login securely with Nostr Connect (under construction):</p>
        <button id="login-connect-btn">login with nostr connect</button>
        <p>Or login with a Nostr browser extension (recommended):</p>
        <button id="login-extension-btn">login with nostr extension</button>
        <p>Or enter your nsec key to login (not recommended):</p>
        <input type="password" id="nsec-input" placeholder="nsec...">
        <button id="nsec-visibility-btn">üëÅÔ∏è</button>
        <input type="password" id="nsec-passphrase" placeholder="Passphrase for encryption">
        <button id="nsec-passphrase-visibility-btn">üëÅÔ∏è</button>
        <button id="login-nsec-btn">login with nsec</button>
        <p class="info">Your Nostr keys are encrypted and stored securely in your browser.</p>
        <p id="login-error" class="error"></p>
    </section>

    <!-- Hive Setup Section -->
    <section id="hive-setup-section" style="display: none;">
        <h2>hive bridge setup</h2>
        <p>Enter your Hive credentials to enable Nostr-to-Hive bridging:</p>
        <input type="text" id="hive-username" placeholder="Hive username">
        <input type="password" id="hive-posting-key" placeholder="Hive Posting Key (starts with 5)">
        <button id="hive-posting-key-visibility-btn">üëÅÔ∏è</button>
        <button id="save-hive-btn">save credentials</button>
        <p class="info">Your Hive Posting Key is encrypted with your login passphrase and stored securely in your browser.</p>
        <p id="hive-error" class="error"></p>
        <p><label><input type="checkbox" id="bridge-toggle" checked> <span id="bridge-label">Disable Nostr-to-Hive bridge</span></label></p>
        <p id="bridge-status" class="status">Bridge: Active</p>
    </section>

    <!-- Main App Section -->
    <section id="app-section" style="display: none;">
        <p id="login-status" class="status"></p>
        <nav>
            <button id="note-btn">+ note</button>
            <button id="menu-btn">‚ò∞</button>
            <div id="menu">
                <a href="#about" id="about-link">about konetik</a>
                <a href="#security" id="security-link">security</a>
                <div>
                    auto-sleep timer:
                    <select id="sleep-timer">
                        <option value="5">5m</option>
                        <option value="10">10m</option>
                        <option value="15">15m</option>
                        <option value="30">30m</option>
                        <option value="60">1h</option>
                        <option value="off">off</option>
                    </select>
                </div>
                <button id="logout-btn">logout</button>
            </div>
        </nav>
        <div id="feed-controls">
            <button id="refresh-btn">refresh feed</button>
            <button id="reload-btn">reload page</button>
        </div>
        <div id="feed"></div>
    </section>

    <!-- Note Modal -->
    <div id="note-modal">
        <h2>+ note</h2>
        <textarea id="note-content" placeholder="What's on your mind?"></textarea>
        <p id="note-error" class="error"></p>
        <button id="cancel-note-btn">cancel</button>
        <button id="post-note-btn">post</button>
    </div>

    <!-- Reply Modal -->
    <div id="reply-modal">
        <h2>reply</h2>
        <textarea id="reply-content" placeholder="Your reply..."></textarea>
        <p id="reply-error" class="error"></p>
        <button id="cancel-reply-btn">cancel</button>
        <button id="post-reply-btn">post</button>
    </div>

    <!-- About Modal -->
    <div id="about-modal">
        <h2>about konetik</h2>
        <p>konetik is a text-only Nostr client with Nostr-to-Hive bridging for low-resource devices and poor internet.</p>
        <p>Features:</p>
        <ul>
            <li>Text-only interface</li>
            <li>Basic Nostr functionality (posts, follows, reply)</li>
            <li>Nostr-to-Hive bridging for Snaps/Waves</li>
            <li>Installable PWA (coming soon)</li>
            <li>Sleep mode to save resources</li>
        </ul>
        <p><strong>Source code:</strong> Coming soon</p>
        <p>Your keys are encrypted and stored securely in your browser.</p>
        <p>Made with ‚ù§Ô∏è by crrdlx. Find me on Nostr: npub1qpduf...a082j</p>
        <button id="close-about-btn">close</button>
    </div>

    <!-- Security Modal -->
    <div id="security-modal">
        <h2>security</h2>
        <p>Your keys are encrypted using strong browser-based encryption (AES-GCM) and stored locally in your browser‚Äôs secure storage (IndexedDB). They are never sent to servers or stored unencrypted. konetik processes all operations in your browser for maximum privacy.</p>
        <button id="close-security-btn">close</button>
    </div>

    <!-- Post Info Modal -->
    <div id="post-info-modal">
        <h2>Post Status</h2>
        <p id="post-info-message"></p>
        <button id="close-post-info-btn">close</button>
    </div>

    <!-- Sleep Mode Overlay -->
    <div id="sleep-overlay">
        <p id="wake-btn">asleep (tap to wake)</p>
    </div>

    <!-- Version Footer -->
    <footer>
        <p class="info">konetik v0.0.15</p>
    </footer>

    <script>
        // Core variables
        const relays = [
            'wss://relay.damus.io',
            'wss://relay.primal.net',
            'wss://relay.nostr.wirednet.jp',
            'wss://purplepag.es'
        ];
        let nostrPubkey = null;
        let hiveCredentials = null;
        let bridgeEnabled = true;
        let postQueue = [];
        let nsec = null;
        let sessionPassphrase = null;
        let lastHivePostTime = 0;
        let dailySnapCount = 0;
        let lastSnapDay = new Date().toDateString();
        let frontEndIndex = 0;
        const frontEnds = ['snaps', 'waves'];
        const FIVE_MINUTES_MS = 5 * 60 * 1000;
        const MAX_SHORTFORM_PER_DAY = 12;

        // Login functions
        async function loginWithExtension() {
            const errorEl = document.getElementById('login-error');
            errorEl.textContent = '';
            console.log('loginWithExtension: window.nostr exists?', !!window.nostr);
            if (window.nostr) {
                try {
                    nostrPubkey = await window.nostr.getPublicKey();
                    console.log('loginWithExtension: got pubkey', nostrPubkey);
                    await updateLoginStatus();
                    showApp();
                } catch (error) {
                    console.error('loginWithExtension: error', error);
                    errorEl.textContent = 'Extension login failed: ' + error.message;
                }
            } else {
                console.log('loginWithExtension: no window.nostr');
                errorEl.textContent = 'Please install a Nostr extension (e.g., Alby, Nos2x)';
            }
        }

        async function loginWithNostrConnect() {
            alert('Nostr Connect login under construction.');
            // TODO: Implement NIP-46
        }

        async function loginWithNsec() {
            const errorEl = document.getElementById('login-error');
            errorEl.textContent = '';
            const nsecInput = document.getElementById('nsec-input').value;
            let passphrase = sessionPassphrase;
            if (!passphrase) {
                passphrase = prompt('Enter passphrase to encrypt Nostr key:');
                if (!passphrase) {
                    errorEl.textContent = 'Passphrase required';
                    return;
                }
            }
            if (!nsecInput) {
                errorEl.textContent = 'Please enter nsec key';
                return;
            }
            if (nsecInput.startsWith('nsec')) {
                try {
                    nsec = nsecInput;
                    nostrPubkey = NostrTools.getPublicKey(NostrTools.nip19.decode(nsecInput).data);
                    sessionPassphrase = passphrase;
                    await saveToIndexedDB('nsec', nsecInput, passphrase);
                    errorEl.textContent = 'Nostr key encrypted and stored securely';
                    // Try loading existing Hive credentials
                    const hiveData = await loadFromIndexedDB('hive', passphrase);
                    if (hiveData) {
                        hiveCredentials = hiveData;
                        document.getElementById('hive-error').textContent = 'Hive credentials loaded';
                    }
                    await updateLoginStatus();
                    showApp();
                } catch (error) {
                    errorEl.textContent = 'Invalid nsec key or encryption failed: ' + error.message;
                }
            } else {
                errorEl.textContent = 'Invalid nsec key format';
            }
        }

        async function updateLoginStatus() {
            const statusEl = document.getElementById('login-status');
            let displayName = '';
            try {
                const pool = new NostrTools.SimplePool();
                const activeRelays = [];
                for (const relay of relays) {
                    const connected = await tryConnect(pool, relay);
                    if (connected) activeRelays.push(relay);
                }
                console.log('Active relays:', activeRelays);
                if (activeRelays.length === 0) {
                    throw new Error('No relays available');
                }
                const sub = pool.subscribeMany(
                    activeRelays,
                    [{ kinds: [0], authors: [nostrPubkey] }],
                    {
                        onevent(event) {
                            try {
                                const metadata = JSON.parse(event.content);
                                displayName = metadata.display_name || metadata.name || '';
                                if (displayName) {
                                    statusEl.textContent = `Logged in on Nostr as: ${displayName}`;
                                    pool.close(activeRelays);
                                }
                            } catch (e) {
                                console.error('Failed to parse metadata:', e);
                            }
                        },
                        oneose() {
                            if (!displayName) {
                                const npub = NostrTools.nip19.npubEncode(nostrPubkey);
                                const prefix = npub.slice(5, 9);
                                const suffix = npub.slice(-4);
                                statusEl.textContent = `Logged in on Nostr as: npub1${prefix}-${suffix}`;
                                pool.close(activeRelays);
                            }
                        }
                    }
                );
                setTimeout(() => {
                    if (!displayName) {
                        const npub = NostrTools.nip19.npubEncode(nostrPubkey);
                        const prefix = npub.slice(5, 9);
                        const suffix = npub.slice(-4);
                        statusEl.textContent = `Logged in on Nostr as: npub1${prefix}-${suffix}`;
                        pool.close(activeRelays);
                    }
                }, 5000);
            } catch (error) {
                console.error('Failed to fetch username:', error);
                const npub = NostrTools.nip19.npubEncode(nostrPubkey);
                const prefix = npub.slice(5, 9);
                const suffix = npub.slice(-4);
                statusEl.textContent = `Logged in on Nostr as: npub1${prefix}-${suffix}`;
            }
        }

        async function tryConnect(pool, relay, maxRetries = 3) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    await pool.ensureRelay(relay);
                    console.log(`Connected to ${relay}`);
                    return true;
                } catch (e) {
                    console.warn(`Retry ${i+1}/${maxRetries} for ${relay}: ${e.message}`);
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
            }
            console.error(`Failed to connect to ${relay} after ${maxRetries} attempts`);
            return false;
        }

        function toggleNsecVisibility() {
            const input = document.getElementById('nsec-input');
            input.type = input.type === 'password' ? 'text' : 'password';
        }

        function toggleNsecPassphraseVisibility() {
            const input = document.getElementById('nsec-passphrase');
            input.type = input.type === 'password' ? 'text' : 'password';
        }

        function toggleHivePostingKeyVisibility() {
            const input = document.getElementById('hive-posting-key');
            input.type = input.type === 'password' ? 'text' : 'password';
        }

        // IndexedDB setup
        async function saveToIndexedDB(type, data, passphrase) {
            try {
                const dbRequest = indexedDB.open('konetik', 1);
                const db = await new Promise((resolve, reject) => {
                    dbRequest.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains('credentials')) {
                            db.createObjectStore('credentials', { keyPath: 'type' });
                        }
                    };
                    dbRequest.onsuccess = () => resolve(dbRequest.result);
                    dbRequest.onerror = () => reject(dbRequest.error);
                });

                const tx = db.transaction(['credentials'], 'readwrite');
                const store = tx.objectStore('credentials');

                const enc = new TextEncoder();
                const key = await crypto.subtle.importKey('raw', enc.encode(passphrase), 'HKDF', false, ['deriveKey']);
                const derivedKey = await crypto.subtle.deriveKey(
                    { name: 'HKDF', salt: enc.encode('konetik'), info: enc.encode('auth'), hash: 'SHA-256' },
                    key, { name: 'AES-GCM', length: 256 }, true, ['encrypt']
                );
                const iv = crypto.getRandomValues(new Uint8Array(12));
                const encrypted = await crypto.subtle.encrypt(
                    { name: 'AES-GCM', iv },
                    derivedKey,
                    enc.encode(JSON.stringify(data))
                );

                const request = store.put({
                    type,
                    iv: btoa(String.fromCharCode(...iv)),
                    encrypted: btoa(String.fromCharCode(...new Uint8Array(encrypted)))
                });

                await new Promise((resolve, reject) => {
                    tx.oncomplete = () => resolve();
                    tx.onerror = () => reject(tx.error);
                    request.onerror = () => reject(request.error);
                });

                db.close();
            } catch (error) {
                console.error(`Failed to save ${type} to IndexedDB:`, error);
                throw error;
            }
        }

        async function loadFromIndexedDB(type, passphrase) {
            try {
                const db = await new Promise((resolve, reject) => {
                    const request = indexedDB.open('konetik', 1);
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains('credentials')) {
                            db.createObjectStore('credentials', { keyPath: 'type' });
                        }
                    };
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });

                if (!db.objectStoreNames.contains('credentials')) {
                    console.error(`Object store 'credentials' not found for ${type}`);
                    db.close();
                    return null;
                }

                const tx = db.transaction(['credentials'], 'readonly');
                const store = tx.objectStore('credentials');
                const request = store.get(type);

                const data = await new Promise((resolve, reject) => {
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });

                db.close();

                if (!data) {
                    return null;
                }

                const enc = new TextEncoder();
                const key = await crypto.subtle.importKey('raw', enc.encode(passphrase), 'HKDF', false, ['deriveKey']);
                const derivedKey = await crypto.subtle.deriveKey(
                    { name: 'HKDF', salt: enc.encode('konetik'), info: enc.encode('auth'), hash: 'SHA-256' },
                    key, { name: 'AES-GCM', length: 256 }, true, ['decrypt']
                );
                const decrypted = await crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv: new Uint8Array(atob(data.iv).split('').map(c => c.charCodeAt(0))) },
                    derivedKey,
                    new Uint8Array(atob(data.encrypted).split('').map(c => c.charCodeAt(0)))
                );
                return JSON.parse(new TextDecoder().decode(decrypted));
            } catch (error) {
                console.error(`Failed to load ${type} from IndexedDB:`, error);
                return null;
            }
        }

        // Validate Hive posting key
        function validateHiveKey(key) {
            if (!key || typeof key !== 'string') return false;
            if (!key.startsWith('5') || key.length < 48 || key.length > 52) {
                alert('Invalid Hive Posting Key. Must start with 5 and be 48-52 characters long.');
                return false;
            }
            try {
                dhive.PrivateKey.fromString(key);
                return true;
            } catch (error) {
                alert('Invalid Hive Posting Key format. Please check and try again.');
                return false;
            }
        }

        function showApp() {
            document.getElementById('login-section').style.display = 'none';
            document.getElementById('hive-setup-section').style.display = 'block';
            document.getElementById('app-section').style.display = 'block';
        }

        // Hive setup
        async function saveHiveCredentials() {
            const errorEl = document.getElementById('hive-error');
            errorEl.textContent = '';
            const username = document.getElementById('hive-username').value;
            const postingKey = document.getElementById('hive-posting-key').value;
            if (!username || !postingKey) {
                errorEl.textContent = 'Please enter Hive username and Posting Key';
                return;
            }
            // Retry initializing hiveClient if null
            if (!hiveClient) {
                await initHiveClient();
                if (!hiveClient) {
                    errorEl.textContent = 'Hive library not loaded. Cannot save credentials.';
                    return;
                }
            }
            if (!validateHiveKey(postingKey)) {
                errorEl.textContent = 'Invalid Hive Posting Key';
                return;
            }
            let passphrase = sessionPassphrase;
            if (!passphrase) {
                passphrase = prompt('Enter passphrase to encrypt Hive credentials:');
                if (!passphrase) {
                    errorEl.textContent = 'Passphrase required to save credentials';
                    return;
                }
            }
            try {
                await saveToIndexedDB('hive', { username, postingKey }, passphrase);
                hiveCredentials = { username, postingKey };
                errorEl.textContent = 'Credentials encrypted and stored securely';
                if (bridgeEnabled) processQueue();
            } catch (error) {
                errorEl.textContent = 'Encryption failed: ' + error.message;
            }
        }

        async function initHiveClient() {
            if (hiveClient) return;
            const dhiveScript = document.getElementById('dhive-script');
            if (window.dhive) {
                dhive = window.dhive;
                hiveClient = new dhive.Client('https://api.hive.blog');
                console.log('dhive initialized from primary source');
                return;
            }
            console.warn('dhive not loaded, attempting fallback');
            await loadDhiveFallback();
        }

        function toggleBridge() {
            bridgeEnabled = document.getElementById('bridge-toggle').checked;
            document.getElementById('bridge-label').textContent = bridgeEnabled ? 'Disable Nostr-to-Hive bridge' : 'Enable Nostr-to-Hive bridge';
            document.getElementById('bridge-status').textContent = `Bridge: ${bridgeEnabled ? 'Active' : 'Inactive'}${!hiveClient ? ' (Hive unavailable)' : ''}`;
            if (bridgeEnabled) processQueue();
        }

        // Container detection
        async function getActiveContainer(frontEnd) {
            if (!hiveClient) {
                await initHiveClient();
                if (!hiveClient) throw new Error('Hive client not initialized');
            }
            const query = {
                tag: frontEnd === 'snaps' ? 'peak.snaps' : 'ecency.waves',
                limit: 1
            };
            try {
                console.log(`Fetching ${frontEnd} container...`);
                const [post] = await hiveClient.database.getDiscussions('blog', query);
                if (!post || post.author !== (frontEnd === 'snaps' ? 'peak.snaps' : 'ecency.waves')) {
                    console.warn(`No valid ${frontEnd} container found`);
                    return null;
                }
                console.log(`Found ${frontEnd} container: ${post.permlink}`);
                return post.permlink;
            } catch (error) {
                console.error(`Error fetching ${frontEnd} container:`, error.message);
                return null;
            }
        }

        // Reset daily counts
        function resetDailyCounts() {
            const today = new Date().toDateString();
            if (today !== lastSnapDay) {
                dailySnapCount = 0;
                lastSnapDay = today;
                console.log('Reset daily snap count');
            }
        }

        // Post info modal
        function showPostInfoModal(message) {
            document.getElementById('post-info-message').textContent = message;
            document.getElementById('post-info-modal').style.display = 'block';
            setTimeout(closePostInfoModal, 3000);
        }

        function closePostInfoModal() {
            document.getElementById('post-info-modal').style.display = 'none';
            document.getElementById('post-info-message').textContent = '';
        }

        // Security modal
        function openSecurity() {
            document.getElementById('security-modal').style.display = 'block';
        }

        function closeSecurity() {
            document.getElementById('security-modal').style.display = 'none';
        }

        // Note posting
        async function postNote() {
            const content = document.getElementById('note-content').value;
            const errorEl = document.getElementById('note-error');
            errorEl.textContent = '';
            if (!content) {
                errorEl.textContent = 'Please enter note content';
                return;
            }
            const event = {
                kind: 1,
                created_at: Math.floor(Date.now() / 1000),
                tags: [['t', 'hostr']],
                content,
                pubkey: nostrPubkey
            };
            try {
                let signedEvent;
                if (window.nostr) {
                    signedEvent = await window.nostr.signEvent(event);
                } else if (nsec) {
                    signedEvent = NostrTools.finalizeEvent(event, NostrTools.nip19.decode(nsec).data);
                } else {
                    throw new Error('No signing method available');
                }
                const pool = new NostrTools.SimplePool();
                const activeRelays = [];
                for (const relay of relays) {
                    const connected = await tryConnect(pool, relay);
                    if (connected) activeRelays.push(relay);
                }
                if (activeRelays.length === 0) {
                    throw new Error('No relays available for publishing');
                }
                await pool.publish(activeRelays, signedEvent);
                let message = 'Note broadcasted to Nostr';
                if (bridgeEnabled && hiveCredentials && hiveClient) {
                    const nevent = NostrTools.nip19.neventEncode({ id: signedEvent.id, relays });
                    postQueue.push({ content, eventId: signedEvent.id, nevent, kind: 1 });
                    processQueue();
                    message += ' and queued for Hive bridging';
                } else if (bridgeEnabled && !hiveClient) {
                    console.warn('Cannot bridge: Hive library not loaded');
                    message += ' (Hive bridging unavailable)';
                    errorEl.textContent = 'Cannot bridge: Hive library not loaded';
                } else if (bridgeEnabled && !hiveCredentials) {
                    console.warn('Cannot bridge: Hive credentials missing');
                    message += ' (Hive credentials missing)';
                    errorEl.textContent = 'Cannot bridge: Hive credentials missing';
                }
                showPostInfoModal(message);
                closeNoteModal();
            } catch (error) {
                errorEl.textContent = 'Failed to post: ' + error.message;
            }
        }

        // Queue processing for Hive
        async function processQueue() {
            if (!bridgeEnabled || postQueue.length === 0 || !hiveCredentials || !hiveClient) {
                document.getElementById('bridge-status').textContent = `Bridge: Inactive (queue: ${postQueue.length})${!hiveClient ? ' (Hive unavailable)' : !hiveCredentials ? ' (credentials missing)' : ''}`;
                return;
            }
            resetDailyCounts();
            if (dailySnapCount >= MAX_SHORTFORM_PER_DAY) {
                document.getElementById('bridge-status').textContent = `Bridge: Daily limit reached (${MAX_SHORTFORM_PER_DAY})`;
                setTimeout(processQueue, 24 * 60 * 60 * 1000);
                return;
            }
            const now = Date.now();
            if (now - lastHivePostTime < FIVE_MINUTES_MS) {
                const waitTime = FIVE_MINUTES_MS - (now - lastHivePostTime);
                document.getElementById('bridge-status').textContent = `Bridge: Waiting ${Math.round(waitTime / 1000)}s (queue: ${postQueue.length})`;
                setTimeout(processQueue, waitTime);
                return;
            }
            const post = postQueue.shift();
            const permlink = `konetik-${frontEnds[frontEndIndex]}-${Math.random().toString(36).substring(2)}`;
            console.log(`Processing post to ${frontEnds[frontEndIndex]}: ${post.eventId}`);
            try {
                const containerPermlink = await getActiveContainer(frontEnds[frontEndIndex]);
                if (!containerPermlink) {
                    console.warn(`No valid ${frontEnds[frontEndIndex]} container found`);
                    postQueue.unshift(post);
                    document.getElementById('bridge-status').textContent = `Bridge: No ${frontEnds[frontEndIndex]} container (queue: ${postQueue.length})`;
                    setTimeout(processQueue, 2 * 60 * 1000);
                    return;
                }
                const body = `${post.content}\n\nBridged via [konetik](https://konetik.vercel.app) v0.0.15, view [original on Nostr](https://njump.me/${post.nevent}).`;
                const postOp = {
                    parent_author: frontEnds[frontEndIndex] === 'snaps' ? 'peak.snaps' : 'ecency.waves',
                    parent_permlink: containerPermlink,
                    author: hiveCredentials.username,
                    permlink,
                    title: '',
                    body,
                    json_metadata: JSON.stringify({ tags: ['hostr', `hostr-${frontEnds[frontEndIndex]}`], app: `konetik-${frontEnds[frontEndIndex]}/0.0.15` })
                };
                console.log(`Posting to Hive: ${permlink}`);
                await hiveClient.broadcast.comment(postOp, dhive.PrivateKey.fromString(hiveCredentials.postingKey));
                dailySnapCount++;
                lastHivePostTime = now;
                frontEndIndex = (frontEndIndex + 1) % frontEnds.length;
                document.getElementById('bridge-status').textContent = `Bridge: Posted to ${frontEnds[frontEndIndex === 0 ? 1 : 0]} (queue: ${postQueue.length})`;
                console.log(`Posted to ${frontEnds[frontEndIndex === 0 ? 1 : 0]}: ${permlink}`);
            } catch (error) {
                console.error('Error posting to Hive:', error.message);
                postQueue.unshift(post);
                document.getElementById('bridge-status').textContent = `Bridge: Error posting (queue: ${postQueue.length})`;
                setTimeout(processQueue, 2 * 60 * 1000);
            }
            if (postQueue.length > 0) setTimeout(processQueue, 100);
        }

        // UI interactions
        function openNoteModal() {
            document.getElementById('note-modal').style.display = 'block';
        }
        function closeNoteModal() {
            document.getElementById('note-modal').style.display = 'none';
            document.getElementById('note-content').value = '';
            document.getElementById('note-error').textContent = '';
        }
        function cancelNote() { closeNoteModal(); }
        function toggleMenu() {
            const menu = document.getElementById('menu');
            menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
        }
        function openAbout() {
            document.getElementById('about-modal').style.display = 'block';
        }
        function closeAbout() {
            document.getElementById('about-modal').style.display = 'none';
        }
        function refreshFeed() { alert('Feed refresh not implemented'); }
        function reloadPage() { window.location.reload(); }
        function setSleepTimer(value) { alert(`Sleep timer set to ${value} (not implemented)`); }
        function wakeApp() { document.getElementById('sleep-overlay').style.display = 'none'; }
        async function logout() {
            nostrPubkey = null;
            hiveCredentials = null;
            nsec = null;
            sessionPassphrase = null;
            bridgeEnabled = true;
            postQueue = [];
            document.getElementById('login-section').style.display = 'block';
            document.getElementById('hive-setup-section').style.display = 'none';
            document.getElementById('app-section').style.display = 'none';
            document.getElementById('bridge-status').textContent = 'Bridge: Active';
            document.getElementById('bridge-toggle').checked = true;
            document.getElementById('bridge-label').textContent = 'Disable Nostr-to-Hive bridge';
            document.getElementById('login-status').textContent = '';
            try {
                const db = await new Promise((resolve, reject) => {
                    const request = indexedDB.open('konetik', 1);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
                const tx = db.transaction(['credentials'], 'readwrite');
                const store = tx.objectStore('credentials');
                await new Promise((resolve, reject) => {
                    const request = store.clear();
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
                db.close();
            } catch (error) {
                console.error('Failed to clear IndexedDB:', error);
            }
        }
        function openReplyModal() { document.getElementById('reply-modal').style.display = 'block'; }
        function closeReplyModal() { document.getElementById('reply-modal').style.display = 'none'; }
        function cancelReply() { closeReplyModal(); }
        function postReply() { alert('Reply posting not implemented'); closeReplyModal(); }

        // Handle dhive loading
        let dhive = null;
        let hiveClient = null;

        async function loadDhiveFallback() {
            const dhiveFallback = document.getElementById('dhive-fallback');
            return new Promise((resolve, reject) => {
                console.log('Attempting dhive fallback from /dhive.js');
                dhiveFallback.src = '/dhive.js';
                dhiveFallback.onload = () => {
                    dhive = window.dhive;
                    if (dhive) {
                        hiveClient = new dhive.Client('https://api.hive.blog');
                        console.log('dhive loaded from fallback');
                        resolve();
                    } else {
                        console.error('dhive fallback failed to attach to window.dhive');
                        document.getElementById('hive-error').textContent = 'Hive library failed to load. Bridging disabled.';
                        reject(new Error('dhive fallback failed'));
                    }
                };
                dhiveFallback.onerror = () => {
                    console.error('Failed to load dhive from /dhive.js');
                    document.getElementById('hive-error').textContent = 'Hive library failed to load. Bridging disabled.';
                    reject(new Error('dhive fallback load error'));
                };
            });
        }

        // Event listeners
        window.addEventListener('load', () => {
            const dhiveScript = document.getElementById('dhive-script');
            if (dhiveScript) {
                dhiveScript.onload = () => {
                    dhive = window.dhive;
                    if (dhive) {
                        hiveClient = new dhive.Client('https://api.hive.blog');
                        console.log('dhive loaded from primary source (CDN)');
                    } else {
                        console.error('dhive failed to attach to window.dhive');
                        loadDhiveFallback();
                    }
                };
                dhiveScript.onerror = () => {
                    console.error('Failed to load dhive from CDN, retrying...');
                    setTimeout(() => {
                        dhiveScript.src = 'https://cdn.jsdelivr.net/npm/@hiveio/dhive@1.3.0/dist/dhive.js';
                        dhiveScript.onload = () => {
                            dhive = window.dhive;
                            if (dhive) {
                                hiveClient = new dhive.Client('https://api.hive.blog');
                                console.log('dhive loaded from CDN retry');
                            } else {
                                loadDhiveFallback();
                            }
                        };
                        dhiveScript.onerror = () => {
                            console.error('Failed to load dhive from CDN after retry');
                            loadDhiveFallback();
                        };
                    }, 1000);
                };
            } else {
                console.error('dhive-script element not found');
                loadDhiveFallback();
            }

            // Bind event listeners
            document.getElementById('login-connect-btn').addEventListener('click', loginWithNostrConnect);
            document.getElementById('login-extension-btn').addEventListener('click', loginWithExtension);
            document.getElementById('nsec-visibility-btn').addEventListener('click', toggleNsecVisibility);
            document.getElementById('nsec-passphrase-visibility-btn').addEventListener('click', toggleNsecPassphraseVisibility);
            document.getElementById('hive-posting-key-visibility-btn').addEventListener('click', toggleHivePostingKeyVisibility);
            document.getElementById('login-nsec-btn').addEventListener('click', loginWithNsec);
            document.getElementById('save-hive-btn').addEventListener('click', saveHiveCredentials);
            document.getElementById('bridge-toggle').addEventListener('change', toggleBridge);
            document.getElementById('note-btn').addEventListener('click', openNoteModal);
            document.getElementById('menu-btn').addEventListener('click', toggleMenu);
            document.querySelectorAll('#about-link').forEach(link => link.addEventListener('click', openAbout));
            document.getElementById('security-link').addEventListener('click', openSecurity);
            document.getElementById('sleep-timer').addEventListener('change', (e) => setSleepTimer(e.target.value));
            document.getElementById('logout-btn').addEventListener('click', logout);
            document.getElementById('refresh-btn').addEventListener('click', refreshFeed);
            document.getElementById('reload-btn').addEventListener('click', reloadPage);
            document.getElementById('cancel-note-btn').addEventListener('click', cancelNote);
            document.getElementById('post-note-btn').addEventListener('click', postNote);
            document.getElementById('cancel-reply-btn').addEventListener('click', cancelReply);
            document.getElementById('post-reply-btn').addEventListener('click', postReply);
            document.getElementById('close-about-btn').addEventListener('click', closeAbout);
            document.getElementById('close-security-btn').addEventListener('click', closeSecurity);
            document.getElementById('close-post-info-btn').addEventListener('click', closePostInfoModal);
            document.getElementById('wake-btn').addEventListener('click', wakeApp);
        });
    </script>
<!-- konetik index.html v0.0.15 -->